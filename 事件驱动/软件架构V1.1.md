## **CANopen多轴同步运动控制：软件架构设计文档**

**版本:** 1.1 &nbsp;&nbsp;
**日期:** 2025年8月20 &nbsp;&nbsp;
**作者:** Yongzhe.Luo

### 1. 概述

本文档旨在详细描述一个用于CANopen多轴同步运动控制的软件架构。该架构的核心目标是实现多个电机（如机械臂的关节）之间的高精度、高确定性同步运动，同时保证软件的模块化、健壮性和可维护性。

该设计严格遵循CANopen的同步机制：**通过过程数据对象（PDO）分发独立的运动指令，再由一个全局同步报文（SYNC）触发所有节点同时执行**。

 `V1.1` 架构相对于 `V1.0` 架构演进在于，**SYNC报文的生产由一个专用的硬件节点（如其中一个电机驱动器）负责**，而非由PC上位机产生。这从根本上解决了非实时操作系统（如Windows/Linux）的定时精度问题。PC上位机的核心任务转变为 **可靠地响应SYNC事件**，确保在下一个SYNC到来之前，将所有必要的PDO数据发送到总线上。

### 2. 核心架构原则

本架构基于两大核心原则：

1.  **关注点分离 (Separation of Concerns)**:
    *   **实时通信任务**与**上层应用逻辑**严格分离。实时任务只负责响应总线事件并执行CAN通信；上层应用则负责运动规划、用户交互和状态监控。
    *   这种分离使得两部分可以独立开发和测试，提高了代码的可维护性。

2.  **硬件同步触发与事件驱动的结合 (Hardware SYNC-Triggered & Event-Driven)**:
    *   系统的核心节拍由网络上的 **硬件SYNC生产者** 提供，保证了整个系统拥有一个高精度、低抖动的“心跳”。
    *   PC端的实时任务是 **事件驱动 (Event-Driven)** 的，它被动地由接收到的SYNC报文事件唤醒，从而执行其通信逻辑。这避免了在非实时操作系统上进行高精度定时编程的复杂性和不确定性。
    *   系统的上层应用逻辑（如用户命令）仍然是事件驱动的。

### 3. 系统组件设计

系统由三个主要的软件组件和一个核心硬件角色构成：

#### 3.1. `SupervisoryController` (监控控制器)

*   **角色**: 应用程序的“大脑”，负责顶层逻辑和用户交互。
*   **职责**:
    *   管理应用程序的生命周期（启动、关闭）。
    *   **负责在系统初始化时，通过SDO配置指定的电机驱动器成为SYNC生产者**。
    *   加载、生成或管理运动轨迹数据。
    *   向`RealTimeSyncTask`发送高级指令（例如：`start_motion`, `stop`）。
    *   监听来自`RealTimeSyncTask`的状态更新（例如：`motion_finished`, `error`）。
*   **执行上下文**: 运行在应用程序的主线程或一个独立的低优先级线程中。

#### 3.2. `RealTimeSyncTask` (实时同步任务)

*   **角色**: CANopen主站的“心脏”，是整个同步机制在PC端的执行核心。
*   **职责**:
    *   在一个独立的、高优先级的线程中运行，以确保对SYNC事件的低延迟响应。
    *   其主循环**阻塞式地等待SYNC报文的到达**，而不是由定时器唤醒。
    *   内部实现一个`状态机(State Machine)`来管理其行为（例如：`IDLE`, `MOTION_ACTIVE`）。
    *   **严格遵守“黄金法则”：在接收到一个SYNC报文后，必须在下一个SYNC报文到来之前，发送完所有为下一个周期准备的数据PDO。**
    *   通过线程安全的队列与`SupervisoryController`进行通信。
*   **执行上下文**: 一个独立的、高优先级的线程。

#### 3.3. `CommunicationBus` (通信总线接口)

*   **角色**: 硬件抽象层（HAL），隔离了上层逻辑与具体的CAN硬件/库。
*   **职责**:
    *   提供API，如 `send_pdo(id, data)`。
    *   提供一个阻塞式的API或回调机制，如 `wait_for_sync()`，用于在接收到SYNC报文时唤醒`RealTimeSyncTask`。
    *   封装具体的CAN库（如`python-can`）的实现细节。
*   **执行上下文**: 被`RealTimeSyncTask`调用。

#### 3.4. 新增核心角色：`SYNC生产者` (SYNC Producer)

*   **角色**: 整个网络的“节拍器”，通常由其中一个电机驱动器担任。
*   **职责**:
    *   在实时环境中，以极高的精度和稳定性，周期性地（如每10ms）向CAN总线广播SYNC报文。
    *   此功能需在系统初始化阶段，由`SupervisoryController`通过SDO报文进行配置和激活（例如，配置对象字典中的`0x1005`和`0x1006`）。

### 4. 组件交互与数据流

组件间的通信通过线程安全的队列实现，而系统的核心节拍由外部硬件驱动。

```
+---------------------------+
|   SupervisoryController   |
| (Main App / Logic / SDOs) |
+---------------------------+
       |             ^
       | Commands    | Status Updates
       V             |
+---------------------------+
|      command_queue        | (Thread-safe Queue)
+---------------------------+
       |
       V
+---------------------------+      +---------------------+
|    RealTimeSyncTask       |----->|  CommunicationBus   |
| (High-Priority Thread)    |      | (Sends PDOs)        |
| *Triggered by SYNC event* |      +---------------------+
|                           |             |
| +-----------------------+ |             V
| |     State Machine     | |      +---------------------+
| +-----------------------+ |      |       CAN Bus       |
+---------------------------+      +---------------------+
       ^                             ^
       | (Listens for SYNC)          | (SYNC is broadcast)
       '----------------------------'|
                                     |
                          +------------------------+
                          | Motor Drive (Node X)   |
                          | **SYNC Producer**      |
                          +------------------------+
```

### 5. `RealTimeSyncTask` 深度解析

#### 5.1. 状态机 (State Machine) 设计

状态机设计保持不变，它定义了任务在不同情况下的行为。

*   **`TaskState.IDLE`**: 空闲状态。任务响应SYNC，但不发送变化的运动指令。
*   **`TaskState.MOTION_ACTIVE`**: 运动激活状态。任务在每次SYNC事件后，发送新的轨迹点。
*   **`TaskState.STOPPING`**: 停止状态。执行平滑减速停止。
*   **`TaskState.ERROR`**: 错误状态。检测到严重问题时进入。

**状态转换图:**
```
          'start_motion' command
       +----------------------------+
       |                            |
       V      'motion_finished'     |
    +------+ <-------------------+ +---------------+
--->| IDLE |                     | | MOTION_ACTIVE |
    +------+ ------------------->+ +---------------+
       ^      'stop' command,         |
       |      graceful stop           | 'stop' command
       |                            |
       +-------------------------+  |
                                 V  V
                               +----------+
                               | STOPPING |
                               +----------+
```
*(注意: 从任何状态都可能因严重故障直接转换到ERROR状态)*

#### 5.2. `MOTION_ACTIVE` 状态的详细逻辑

此状态的逻辑由 **外部SYNC事件** 驱动。

##### **进入状态 (Entry Action)**
当从`IDLE`状态收到`start_motion`指令后，在进入`MOTION_ACTIVE`状态的**第一个周期前**执行：
1.  从指令中获取轨迹数据，并将其引用保存在`self.current_trajectory`。
2.  **将步进指针 `self.trajectory_step` 重置为 `0`。**

##### **周期性执行 (Cyclic Action, Triggered by SYNC)**
每当`CommunicationBus`接收到一个SYNC报文，`RealTimeSyncTask`的主循环被唤醒，并执行以下步骤：
1.  **检查完成条件**: 判断`self.trajectory_step`是否已达到或超过轨迹的总长度。
    *   **如果是**: 执行“退出状态”的逻辑。
    *   **如果否**: 继续下一步。
2.  **获取数据**: 使用`self.trajectory_step`作为索引，从`self.current_trajectory`中获取 **下一个周期** 的目标位置数据。
3.  **发送所有PDOs**: 将获取到的多轴目标位置打包成一个或多个PDO，并**立即、连续地**发送到总线上。**此操作必须在下一个SYNC报文到来前完成。**
4.  **更新指针**: 将`self.trajectory_step`加 `1`，为响应下一个SYNC事件做准备。

##### **退出状态 (Exit Action)**
当轨迹执行完成后（由步骤1检测到）：
1.  向`status_queue`发送一条`motion_finished`消息，通知`SupervisoryController`。
2.  将任务状态切换回`TaskState.IDLE`。
3.  （可选）清理`self.current_trajectory`引用（设为`None`）。